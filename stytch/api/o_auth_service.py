# !!!
# WARNING: This file is autogenerated
# Only modify code within MANUAL() sections
# or your changes may be overwritten later!
# !!!

from typing import Any, Dict, List, Optional, Union

import pydantic

from stytch.core.api_base import ApiBase
from stytch.core.http.client import AsyncClient, SyncClient
from stytch.models.o_auth_service import (
  OauthattachResponse,
  OauthgoogleonetapstartResponse,
  OauthgooglestartResponse,
  OauthgoogleidtokenauthenticateResponse,
  OauthmicrosoftstartResponse,
  OauthapplestartResponse,
  OauthappleidtokenauthenticateResponse,
  OauthgithubstartResponse,
  OauthfacebookstartResponse,
  OauthamazonstartResponse,
  OauthbitbucketstartResponse,
  OauthcoinbasestartResponse,
  OauthdiscordstartResponse,
  OauthfigmastartResponse,
  OauthgitlabstartResponse,
  OauthinstagramstartResponse,
  OauthlinkedinstartResponse,
  OauthshopifystartResponse,
  OauthslackstartResponse,
  OauthsnapchatstartResponse,
  OauthspotifystartResponse,
  OauthsteamstartResponse,
  OauthtiktokstartResponse,
  OauthtwitchstartResponse,
  OauthtwitterstartResponse,
  OauthauthenticateResponse,
)


class OAuthService:
    def __init__(
      self,
      api_base: ApiBase,
      sync_client: SyncClient,
      async_client: AsyncClient,
    ) -> None:
        self.api_base = api_base
        self.sync_client = sync_client
        self.async_client = async_client

    @property
    def sub_url(self) -> str:
        return "o_auth_service"

    def OAuthAttach(
        self,
        provider: str,
        user_id: str,
        session_token: Optional[str] = None,
        session_jwt: Optional[str] = None,
    ) -> OauthattachResponse:

        payload: Dict[str, Any] = {
            "provider": provider,
            "user_id": user_id,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/oauth/attach")

        res = self.sync_client.post(url, json=payload)
        return OauthattachResponse.from_json(res.response.status_code, res.json)

    async def OAuthAttach_async(
      self,
      provider: str,
      user_id: str,
      session_token: Optional[str] = None,
      session_jwt: Optional[str] = None,
    ) -> OauthattachResponse:

        payload: Dict[str, Any] = {
            "provider": provider,
            "user_id": user_id,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/oauth/attach")

        res = await self.async_client.post(url, json=payload)
        return OauthattachResponse.from_json(res.response.status, res.json)

    def OAuthGoogleOneTapStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
    ) -> OauthgoogleonetapstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/google/onetap/start")

        res = self.sync_client.get(url, params=payload)
        return OauthgoogleonetapstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthGoogleOneTapStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
    ) -> OauthgoogleonetapstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/google/onetap/start")

        res = await self.async_client.get(url, params=payload)
        return OauthgoogleonetapstartResponse.from_json(res.response.status, res.json)

    def OAuthGoogleStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthgooglestartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/google/start")

        res = self.sync_client.get(url, params=payload)
        return OauthgooglestartResponse.from_json(res.response.status_code, res.json)

    async def OAuthGoogleStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthgooglestartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/google/start")

        res = await self.async_client.get(url, params=payload)
        return OauthgooglestartResponse.from_json(res.response.status, res.json)

    def OAuthGoogleIDTokenAuthenticate(
        self,
        id_token: str,
        session_token: Optional[str] = None,
        session_duration_minutes: Optional[int] = None,
        session_jwt: Optional[str] = None,
        session_custom_claims: Optional[Dict[str, str]] = None,
    ) -> OauthgoogleidtokenauthenticateResponse:

        payload: Dict[str, Any] = {
            "id_token": id_token,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/oauth/google/id_token/authenticate")

        res = self.sync_client.post(url, json=payload)
        return OauthgoogleidtokenauthenticateResponse.from_json(res.response.status_code, res.json)

    async def OAuthGoogleIDTokenAuthenticate_async(
      self,
      id_token: str,
      session_token: Optional[str] = None,
      session_duration_minutes: Optional[int] = None,
      session_jwt: Optional[str] = None,
      session_custom_claims: Optional[Dict[str, str]] = None,
    ) -> OauthgoogleidtokenauthenticateResponse:

        payload: Dict[str, Any] = {
            "id_token": id_token,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/oauth/google/id_token/authenticate")

        res = await self.async_client.post(url, json=payload)
        return OauthgoogleidtokenauthenticateResponse.from_json(res.response.status, res.json)

    def OAuthMicrosoftStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthmicrosoftstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/microsoft/start")

        res = self.sync_client.get(url, params=payload)
        return OauthmicrosoftstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthMicrosoftStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthmicrosoftstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/microsoft/start")

        res = await self.async_client.get(url, params=payload)
        return OauthmicrosoftstartResponse.from_json(res.response.status, res.json)

    def OAuthAppleStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthapplestartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/apple/start")

        res = self.sync_client.get(url, params=payload)
        return OauthapplestartResponse.from_json(res.response.status_code, res.json)

    async def OAuthAppleStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthapplestartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/apple/start")

        res = await self.async_client.get(url, params=payload)
        return OauthapplestartResponse.from_json(res.response.status, res.json)

    def OAuthAppleIDTokenAuthenticate(
        self,
        id_token: str,
        session_token: Optional[str] = None,
        session_duration_minutes: Optional[int] = None,
        session_jwt: Optional[str] = None,
        session_custom_claims: Optional[Dict[str, str]] = None,
        name: None,
        nonce: str,
    ) -> OauthappleidtokenauthenticateResponse:

        payload: Dict[str, Any] = {
            "id_token": id_token,
            "nonce": nonce,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims
        if name is not None:
            payload["name"] = name

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/oauth/apple/id_token/authenticate")

        res = self.sync_client.post(url, json=payload)
        return OauthappleidtokenauthenticateResponse.from_json(res.response.status_code, res.json)

    async def OAuthAppleIDTokenAuthenticate_async(
      self,
      id_token: str,
      session_token: Optional[str] = None,
      session_duration_minutes: Optional[int] = None,
      session_jwt: Optional[str] = None,
      session_custom_claims: Optional[Dict[str, str]] = None,
      name: None,
      nonce: str,
    ) -> OauthappleidtokenauthenticateResponse:

        payload: Dict[str, Any] = {
            "id_token": id_token,
            "nonce": nonce,
        }

        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims
        if name is not None:
            payload["name"] = name

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/oauth/apple/id_token/authenticate")

        res = await self.async_client.post(url, json=payload)
        return OauthappleidtokenauthenticateResponse.from_json(res.response.status, res.json)

    def OAuthGithubStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthgithubstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/github/start")

        res = self.sync_client.get(url, params=payload)
        return OauthgithubstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthGithubStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthgithubstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/github/start")

        res = await self.async_client.get(url, params=payload)
        return OauthgithubstartResponse.from_json(res.response.status, res.json)

    def OAuthFacebookStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthfacebookstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/facebook/start")

        res = self.sync_client.get(url, params=payload)
        return OauthfacebookstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthFacebookStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthfacebookstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/facebook/start")

        res = await self.async_client.get(url, params=payload)
        return OauthfacebookstartResponse.from_json(res.response.status, res.json)

    def OAuthAmazonStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthamazonstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/amazon/start")

        res = self.sync_client.get(url, params=payload)
        return OauthamazonstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthAmazonStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthamazonstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/amazon/start")

        res = await self.async_client.get(url, params=payload)
        return OauthamazonstartResponse.from_json(res.response.status, res.json)

    def OAuthBitbucketStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthbitbucketstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/bitbucket/start")

        res = self.sync_client.get(url, params=payload)
        return OauthbitbucketstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthBitbucketStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthbitbucketstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/bitbucket/start")

        res = await self.async_client.get(url, params=payload)
        return OauthbitbucketstartResponse.from_json(res.response.status, res.json)

    def OAuthCoinbaseStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthcoinbasestartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/coinbase/start")

        res = self.sync_client.get(url, params=payload)
        return OauthcoinbasestartResponse.from_json(res.response.status_code, res.json)

    async def OAuthCoinbaseStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthcoinbasestartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/coinbase/start")

        res = await self.async_client.get(url, params=payload)
        return OauthcoinbasestartResponse.from_json(res.response.status, res.json)

    def OAuthDiscordStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthdiscordstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/discord/start")

        res = self.sync_client.get(url, params=payload)
        return OauthdiscordstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthDiscordStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthdiscordstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/discord/start")

        res = await self.async_client.get(url, params=payload)
        return OauthdiscordstartResponse.from_json(res.response.status, res.json)

    def OAuthFigmaStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthfigmastartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/figma/start")

        res = self.sync_client.get(url, params=payload)
        return OauthfigmastartResponse.from_json(res.response.status_code, res.json)

    async def OAuthFigmaStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthfigmastartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/figma/start")

        res = await self.async_client.get(url, params=payload)
        return OauthfigmastartResponse.from_json(res.response.status, res.json)

    def OAuthGitLabStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthgitlabstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/gitlab/start")

        res = self.sync_client.get(url, params=payload)
        return OauthgitlabstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthGitLabStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthgitlabstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/gitlab/start")

        res = await self.async_client.get(url, params=payload)
        return OauthgitlabstartResponse.from_json(res.response.status, res.json)

    def OAuthInstagramStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthinstagramstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/instagram/start")

        res = self.sync_client.get(url, params=payload)
        return OauthinstagramstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthInstagramStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthinstagramstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/instagram/start")

        res = await self.async_client.get(url, params=payload)
        return OauthinstagramstartResponse.from_json(res.response.status, res.json)

    def OAuthLinkedInStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthlinkedinstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/linkedin/start")

        res = self.sync_client.get(url, params=payload)
        return OauthlinkedinstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthLinkedInStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthlinkedinstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/linkedin/start")

        res = await self.async_client.get(url, params=payload)
        return OauthlinkedinstartResponse.from_json(res.response.status, res.json)

    def OAuthShopifyStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthshopifystartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/shopify/start")

        res = self.sync_client.get(url, params=payload)
        return OauthshopifystartResponse.from_json(res.response.status_code, res.json)

    async def OAuthShopifyStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthshopifystartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/shopify/start")

        res = await self.async_client.get(url, params=payload)
        return OauthshopifystartResponse.from_json(res.response.status, res.json)

    def OAuthSlackStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthslackstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/slack/start")

        res = self.sync_client.get(url, params=payload)
        return OauthslackstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthSlackStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthslackstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/slack/start")

        res = await self.async_client.get(url, params=payload)
        return OauthslackstartResponse.from_json(res.response.status, res.json)

    def OAuthSnapchatStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthsnapchatstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/snapchat/start")

        res = self.sync_client.get(url, params=payload)
        return OauthsnapchatstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthSnapchatStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthsnapchatstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/snapchat/start")

        res = await self.async_client.get(url, params=payload)
        return OauthsnapchatstartResponse.from_json(res.response.status, res.json)

    def OAuthSpotifyStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthspotifystartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/spotify/start")

        res = self.sync_client.get(url, params=payload)
        return OauthspotifystartResponse.from_json(res.response.status_code, res.json)

    async def OAuthSpotifyStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthspotifystartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/spotify/start")

        res = await self.async_client.get(url, params=payload)
        return OauthspotifystartResponse.from_json(res.response.status, res.json)

    def OAuthSteamStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthsteamstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/steam/start")

        res = self.sync_client.get(url, params=payload)
        return OauthsteamstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthSteamStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthsteamstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/steam/start")

        res = await self.async_client.get(url, params=payload)
        return OauthsteamstartResponse.from_json(res.response.status, res.json)

    def OAuthTikTokStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthtiktokstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/tiktok/start")

        res = self.sync_client.get(url, params=payload)
        return OauthtiktokstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthTikTokStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthtiktokstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/tiktok/start")

        res = await self.async_client.get(url, params=payload)
        return OauthtiktokstartResponse.from_json(res.response.status, res.json)

    def OAuthTwitchStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthtwitchstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/twitch/start")

        res = self.sync_client.get(url, params=payload)
        return OauthtwitchstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthTwitchStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthtwitchstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/twitch/start")

        res = await self.async_client.get(url, params=payload)
        return OauthtwitchstartResponse.from_json(res.response.status, res.json)

    def OAuthTwitterStart(
        self,
        public_token: str,
        login_redirect_url: Optional[str] = None,
        signup_redirect_url: Optional[str] = None,
        custom_scopes: str,
        code_challenge: Optional[str] = None,
        oauth_attach_token: Optional[str] = None,
    ) -> OauthtwitterstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/twitter/start")

        res = self.sync_client.get(url, params=payload)
        return OauthtwitterstartResponse.from_json(res.response.status_code, res.json)

    async def OAuthTwitterStart_async(
      self,
      public_token: str,
      login_redirect_url: Optional[str] = None,
      signup_redirect_url: Optional[str] = None,
      custom_scopes: str,
      code_challenge: Optional[str] = None,
      oauth_attach_token: Optional[str] = None,
    ) -> OauthtwitterstartResponse:

        payload: Dict[str, Any] = {
            "public_token": public_token,
            "custom_scopes": custom_scopes,
        }

        if login_redirect_url is not None:
            payload["login_redirect_url"] = login_redirect_url
        if signup_redirect_url is not None:
            payload["signup_redirect_url"] = signup_redirect_url
        if code_challenge is not None:
            payload["code_challenge"] = code_challenge
        if oauth_attach_token is not None:
            payload["oauth_attach_token"] = oauth_attach_token

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/public/oauth/twitter/start")

        res = await self.async_client.get(url, params=payload)
        return OauthtwitterstartResponse.from_json(res.response.status, res.json)

    def OAuthAuthenticate(
        self,
        token: str,
        session_management_type: Optional[str] = None,
        session_token: Optional[str] = None,
        session_duration_minutes: Optional[int] = None,
        session_jwt: Optional[str] = None,
        session_custom_claims: Optional[Dict[str, str]] = None,
        code_verifier: Optional[str] = None,
    ) -> OauthauthenticateResponse:

        payload: Dict[str, Any] = {
            "token": token,
        }

        if session_management_type is not None:
            payload["session_management_type"] = session_management_type
        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims
        if code_verifier is not None:
            payload["code_verifier"] = code_verifier

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/oauth/authenticate")

        res = self.sync_client.post(url, json=payload)
        return OauthauthenticateResponse.from_json(res.response.status_code, res.json)

    async def OAuthAuthenticate_async(
      self,
      token: str,
      session_management_type: Optional[str] = None,
      session_token: Optional[str] = None,
      session_duration_minutes: Optional[int] = None,
      session_jwt: Optional[str] = None,
      session_custom_claims: Optional[Dict[str, str]] = None,
      code_verifier: Optional[str] = None,
    ) -> OauthauthenticateResponse:

        payload: Dict[str, Any] = {
            "token": token,
        }

        if session_management_type is not None:
            payload["session_management_type"] = session_management_type
        if session_token is not None:
            payload["session_token"] = session_token
        if session_duration_minutes is not None:
            payload["session_duration_minutes"] = session_duration_minutes
        if session_jwt is not None:
            payload["session_jwt"] = session_jwt
        if session_custom_claims is not None:
            payload["session_custom_claims"] = session_custom_claims
        if code_verifier is not None:
            payload["code_verifier"] = code_verifier

        url = self.api_base.route_with_sub_url(self.sub_url, "/v1/oauth/authenticate")

        res = await self.async_client.post(url, json=payload)
        return OauthauthenticateResponse.from_json(res.response.status, res.json)

